<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-15T07:45:44.363Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React优化-记忆化技术-提升你的React性能</title>
    <link href="http://yoursite.com/2018/06/15/React%E4%BC%98%E5%8C%96-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%8A%80%E6%9C%AF-%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84React%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2018/06/15/React优化-记忆化技术-提升你的React性能/</id>
    <published>2018-06-15T06:14:31.000Z</published>
    <updated>2018-06-15T07:45:44.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用记忆性技术？"><a href="#为什么要使用记忆性技术？" class="headerlink" title="为什么要使用记忆性技术？"></a>为什么要使用记忆性技术？</h4><p>使用React开发的时候，我们请求服务器拿回来一个复杂的数据，我们在render里去处理这个数据，但是state和props频繁修改会触发render，每次触发render，数据都要去处理一次，每次处理都是对性能的损耗</p><p><strong>举个例子：把大于18岁的人列出来</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; dataList &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> newDataList = dataList.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.age &gt; <span class="number">18</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                ...</span><br><span class="line">                &lt;List data=&#123;newDataList&#125; /&gt;</span><br><span class="line">                ...</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>从例子中我们看到render中我们处理数据，但是每次state和props的修改都会触发render，都会去处理数据dataList，生成新的数据newDataList，每次处理都是对性能的损耗！</p><h4 id="什么叫记忆性技术？"><a href="#什么叫记忆性技术？" class="headerlink" title="什么叫记忆性技术？"></a>什么叫记忆性技术？</h4><p>每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！</p><h4 id="memoize-one官方案例"><a href="#memoize-one官方案例" class="headerlink" title="memoize-one官方案例"></a>memoize-one官方案例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoizeOne <span class="keyword">from</span> <span class="string">'memoize-one'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> memoizedAdd = memoizeOne(add);</span><br><span class="line"></span><br><span class="line">memoizedAdd(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">memoizedAdd(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Add 函数并没有执行: 前一次执行的结果被返回</span></span><br><span class="line"></span><br><span class="line">memoizedAdd(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// Add 函数再次被调用，返回一个新的结果</span></span><br><span class="line"></span><br><span class="line">memoizedAdd(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// Add 函数并没有执行: 前一次执行的结果被返回</span></span><br><span class="line"></span><br><span class="line">memoizedAdd(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// Add 函数再次被调用，返回一个新的结果</span></span><br></pre></td></tr></table></figure><p>我们可以发现连续两次相同传参，第二次会直接返回上次的结果，每次传参不一样，就直接调用函数返回新的结果，会丢失之前的记录，并不是完全记忆，这也是个不足点！</p><h4 id="在React中使用memoize-one"><a href="#在React中使用memoize-one" class="headerlink" title="在React中使用memoize-one"></a>在React中使用memoize-one</h4><p>根据上的例子，我们对那个例子进行修改，使用memoize-one提升React的性能<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoize <span class="keyword">from</span> <span class="string">"memoize-one"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    filter = memoize(<span class="function">(<span class="params">dataList</span>) =&gt;</span> dataList.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.age &gt; <span class="number">18</span>))</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; dataList &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">        <span class="keyword">const</span> newDataList = <span class="keyword">this</span>.filter()</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                ...</span><br><span class="line">                &lt;List data=&#123;newDataList&#125; /&gt;</span><br><span class="line">                ...</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="memoize-one源码解析"><a href="#memoize-one源码解析" class="headerlink" title="memoize-one源码解析"></a>memoize-one源码解析</h4><p>memoize-one是采用闭包来缓存数据的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type EqualityFn = <span class="function">(<span class="params">a: mixed, b: mixed</span>) =&gt;</span> boolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleIsEqual: EqualityFn = (a: mixed, <span class="attr">b</span>: mixed): <span class="function"><span class="params">boolean</span> =&gt;</span> a === b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> &lt;<span class="title">ResultFn</span>: (<span class="params">...Array&lt;any&gt;</span>) =&gt; <span class="title">mixed</span>&gt;(<span class="params">resultFn: ResultFn, isEqual?: EqualityFn = simpleIsEqual</span>): <span class="title">ResultFn</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> lastThis: mixed; <span class="comment">// 用来缓存上一次result函数对象</span></span><br><span class="line">  <span class="keyword">let</span> lastArgs: <span class="built_in">Array</span>&lt;mixed&gt; = []; <span class="comment">// 用来缓存上一次的传参</span></span><br><span class="line">  <span class="keyword">let</span> lastResult: mixed; <span class="comment">// 用来缓存上一次的结果</span></span><br><span class="line">  <span class="keyword">let</span> calledOnce: boolean = <span class="literal">false</span>; <span class="comment">// 是否之前调用过</span></span><br><span class="line">  <span class="comment">// 判断两次调用的时候的参数是否相等</span></span><br><span class="line">  <span class="comment">// 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等</span></span><br><span class="line">  <span class="keyword">const</span> isNewArgEqualToLast = (newArg: mixed, <span class="attr">index</span>: number): <span class="function"><span class="params">boolean</span> =&gt;</span> isEqual(newArg, lastArgs[index]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> result = <span class="function"><span class="keyword">function</span> (<span class="params">...newArgs: Array&lt;mixed&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (calledOnce &amp;&amp;</span><br><span class="line">      lastThis === <span class="keyword">this</span> &amp;&amp;</span><br><span class="line">      newArgs.length === lastArgs.length &amp;&amp;</span><br><span class="line">      newArgs.every(isNewArgEqualToLast)) &#123;</span><br><span class="line">      <span class="comment">// 返回之前的结果</span></span><br><span class="line">      <span class="keyword">return</span> lastResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calledOnce = <span class="literal">true</span>; <span class="comment">// 标记已经调用过</span></span><br><span class="line">    lastThis = <span class="keyword">this</span>; <span class="comment">// 重新缓存result对象</span></span><br><span class="line">    lastArgs = newArgs; <span class="comment">// 重新缓存参数</span></span><br><span class="line">    lastResult = resultFn.apply(<span class="keyword">this</span>, newArgs); <span class="comment">// 重新缓存结果</span></span><br><span class="line">    <span class="keyword">return</span> lastResult; <span class="comment">// 返回新的结果</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回闭包函数</span></span><br><span class="line">  <span class="keyword">return</span> (result: any);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="关于isEqual函数（memoize-one推荐使用loadsh-isEqual）"><a href="#关于isEqual函数（memoize-one推荐使用loadsh-isEqual）" class="headerlink" title="关于isEqual函数（memoize-one推荐使用loadsh.isEqual）"></a>关于isEqual函数（memoize-one推荐使用loadsh.isEqual）</h4><p>一般两个对象比较是否相等，我们不能用===或者==来处理，memoize-one允许用户自定义传入判断是否相等的函数，比如我们可以使用lodash的isEqual来判断两次参数是否相等<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> memoizeOne <span class="keyword">from</span> <span class="string">'memoize-one'</span>;</span><br><span class="line"><span class="keyword">import</span> deepEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> identity = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultMemoization = memoizeOne(identity);</span><br><span class="line"><span class="keyword">const</span> customMemoization = memoizeOne(identity, deepEqual);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = defaultMemoization(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> result2 = defaultMemoization(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;);</span><br><span class="line"></span><br><span class="line">result1 === result2 <span class="comment">// false - 索引不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result3 = customMemoization(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> result4 = customMemoization(&#123;<span class="attr">foo</span>: <span class="string">'bar'</span>&#125;);</span><br><span class="line"></span><br><span class="line">result3 === result4 <span class="comment">// true - 参数通过lodash.isEqual判断是相等的</span></span><br></pre></td></tr></table></figure></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/alexreardon/memoize-one" target="_blank" rel="noopener">https://github.com/alexreardon/memoize-one</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用记忆性技术？&quot;&gt;&lt;a href=&quot;#为什么要使用记忆性技术？&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用记忆性技术？&quot;&gt;&lt;/a&gt;为什么要使用记忆性技术？&lt;/h4&gt;&lt;p&gt;使用React开发的时候，我们请求服务器拿回来一个复杂的数据
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Webpack小技巧-公共组件引用路径简化</title>
    <link href="http://yoursite.com/2018/06/15/webpack%E5%B0%8F%E6%8A%80%E5%B7%A7-%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8%E8%B7%AF%E5%BE%84%E7%AE%80%E5%8C%96/"/>
    <id>http://yoursite.com/2018/06/15/webpack小技巧-公共组件引用路径简化/</id>
    <published>2018-06-15T06:02:10.000Z</published>
    <updated>2018-06-15T06:15:13.009Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中，我们会常常把一些功能提取出来，包装成一个公共模块或者组件，供不同地方使用，但是随着项目不断变大，项目目录不断变深，我们引用公共组件的路径越来越长！</p><p>例如：引用一个公共模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Menu <span class="keyword">from</span> <span class="string">'../../../../../components/Menu'</span>; <span class="comment">// 这里路径太深，很容易写错</span></span><br></pre></td></tr></table></figure></p><p><strong>我们该怎么优化尼？</strong></p><h4 id="解决方案1：使用webpack的resolve-alias属性"><a href="#解决方案1：使用webpack的resolve-alias属性" class="headerlink" title="解决方案1：使用webpack的resolve.alias属性"></a>解决方案1：使用webpack的<a href="https://webpack.js.org/configuration/resolve/" target="_blank" rel="noopener">resolve.alias</a>属性</h4><p>先配置webpack<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">"@commModule"</span>: path.resolve(__dirname, <span class="string">"src/components/"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>引用Menu模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Menu <span class="keyword">from</span> <span class="string">'@commModule/Menu'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="解决方案2：babel-plugin-module-resolver"><a href="#解决方案2：babel-plugin-module-resolver" class="headerlink" title="解决方案2：babel-plugin-module-resolver"></a>解决方案2：<a href="https://github.com/tleunen/babel-plugin-module-resolver" target="_blank" rel="noopener">babel-plugin-module-resolver</a></h4><p>配置.babelrc<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [<span class="string">"module-resolver"</span>, &#123;</span><br><span class="line">            <span class="string">"alias"</span>: &#123;</span><br><span class="line">                <span class="string">"@commMdule"</span>: <span class="string">"./src/components"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引用Menu模块<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Menu <span class="keyword">from</span> <span class="string">'@commModule/Menu'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>或许这只是一个小优化，但是在实际场景中，能够大大的降低我们的维护成本，提高我们的生产效率！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常开发中，我们会常常把一些功能提取出来，包装成一个公共模块或者组件，供不同地方使用，但是随着项目不断变大，项目目录不断变深，我们引用公共组件的路径越来越长！&lt;/p&gt;
&lt;p&gt;例如：引用一个公共模块&lt;br&gt;&lt;figure class=&quot;highlight javascript
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
</feed>
