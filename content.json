{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-09T07:17:00.000Z","updated":"2018-05-09T07:17:00.623Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"函数防抖与函数节流","slug":"函数防抖与函数节流","date":"2018-09-06T07:44:06.000Z","updated":"2018-09-06T09:03:06.367Z","comments":true,"path":"2018/09/06/函数防抖与函数节流/","link":"","permalink":"http://yoursite.com/2018/09/06/函数防抖与函数节流/","excerpt":"","text":"函数节流（throttle）名词解释函数节流（throttle）：连续执行函数，每隔一定时间执行函数 使用场景鼠标移动，mousemove 事件DOM 元素动态定位，window对象的resize和scroll 事件等等… 函数节流（throttle）简单实现1234567891011121314151617181920function throttle(fn, delay) &#123; var last; // 上次执行的时间 var timer; // 定时器 delay || (delay = 250); // 默认间隔为250ms return function() &#123; var context = this; var args = arguments; var now = +new Date(); // 现在的时间 if (last &amp;&amp; now &lt; last + delay) &#123; // 当前距离上次执行的时间小于设置的时间间隔 clearTimeout(timer); // 清除定时器 timer = setTimeout(function() &#123; // delay时间后，执行函数 last = now; fn.apply(context, args); &#125;, delay); &#125; else &#123; // 当前距离上次执行的时间大于等于设置的时间，直接执行函数 last = now; fn.apply(context, args); &#125; &#125;;&#125; 函数防抖（debounce）名词解释函数防抖（debounce）：空闲时间必须大于或等于一定值的时候，才会执行调用方法 使用场景文本输入keydown 事件等等… 函数防抖（debounce）简单实现123456789101112function debounce(fn, delay) &#123; var timer; // 定时器 delay || (delay = 250); // 默认空闲时间250ms return function() &#123; var context = this; var args = arguments; clearTimeout(timer); // 清除定时器 timer = setTimeout(function() &#123; // delay时间后，执行函数 fn.apply(context, args); &#125;, delay); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"深浅拷贝","slug":"深浅拷贝","date":"2018-08-16T06:01:04.000Z","updated":"2018-08-16T07:59:30.886Z","comments":true,"path":"2018/08/16/深浅拷贝/","link":"","permalink":"http://yoursite.com/2018/08/16/深浅拷贝/","excerpt":"","text":"深浅拷贝简介javascript中对于Object和Array这两个类型，把一个变量赋值给另一个变量；浅拷贝只是对拷贝对象的引用，深拷贝是彻底拷贝，生成一个新的属性相同的对象 浅拷贝（shallow copy） 浅拷贝只是对拷贝对的引用，两者相互影响 浅拷贝的实现1.简单赋值实现例子：obj2拷贝了obj1，obj2改变，obj1也会改变，改变之后2者还是相同的123456var obj1 = &#123;a: 1&#125;var obj2 = obj1obj2.b = 2console.log(obj1) // &#123;a: 1, b: 2&#125;console.log(obj2) //&#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // true Object.assign()实现例子：当第一个传参是你需要拷贝的对象（PS：Object.assign()也可以实现深拷贝）123456var obj1 = &#123;a: 1&#125;var obj2 = Object.assign(obj1)obj2.b = 2console.log(obj1) // &#123;a: 1, b: 2&#125;console.log(obj2) // &#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // true 深拷贝（deep copy） 彻底拷贝，生成一个新的属性相同的对象 深拷贝的实现Object.assign()实现例子：拷贝对象不是第一个传参123456var obj1 = &#123;a: 1&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // false Array.slice()可以实现数组的深拷贝（数组中不能有Object和Array，Object和Array只是浅拷贝）1234567var arr1 = [1, [2]]var arr2 = arr1.slice()arr2[1].push(3)arr2.push(4)console.log(arr1) // [1, [2, 3]]console.log(arr2) // [1, [2, 3], 4]console.log(arr1 == arr2) // false JSON.stringify()和JSON.parse()实现123456var obj1 = &#123;a: 1&#125;var obj2 = JSON.parse(JSON.stringify(obj1))console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; 递归实现12345678910111213141516var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125;var obj1 = &#123;a: 1&#125;var obj2 = deepCopy(obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; Object.create()实现12345678910111213141516var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? Object.create(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125;var obj1 = &#123;a: 1&#125;var obj2 = deepCopy(obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; jQuery.extend()实现123456var obj1 = &#123;a: 1&#125;var obj2 = $.extend(true, &#123;&#125;, obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; jQuery.extend()源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263jQuery.extend = jQuery.fn.extend = function() &#123; var src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, // 默认取第一个参数赋值给target i = 1, length = arguments.length, // 获取参数的个数 deep = false; // 默认浅拷贝 // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; // 如果第一个参数类型为boolean，那么把该参数赋值给局部变量deep deep = target; target = arguments[1] || &#123;&#125;; // 把第二个参数赋值给target // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target) ) &#123; // target不是object类型或者不是function，就赋值&#123;&#125; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; // 如果只有一个参数，这时候i就是1，length也就是1，那么把target设置为调用者，也就是jQuery对象本身!同时把i递减为0 target = this; // this就是jQuery --i; &#125; for ( ; i &lt; length; i++ ) &#123; // 循环参数 // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; // 防止无休止循环 continue; &#125; // Recurse if we're merging plain objects or arrays // deep是否深拷贝，copy是参数属性值 if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; // 被拷贝的属性值是数组 copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; // 不是数组 clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // 递归~ // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; // 浅拷贝，且属性值不为undefined target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 更多方法…敬请期待","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React优化-JSX模板优化-标签化","slug":"React优化-JSX模板优化-标签化","date":"2018-06-20T03:31:43.000Z","updated":"2018-06-20T03:43:42.595Z","comments":true,"path":"2018/06/20/React优化-JSX模板优化-标签化/","link":"","permalink":"http://yoursite.com/2018/06/20/React优化-JSX模板优化-标签化/","excerpt":"","text":"什么是JSXJSX是JavaScrip的一种扩展语法，JSX的标签语法既不是字符串也不是HTML；从本质上讲，JSX只是为React.createElement(component, props, …children)函数提供的语法糖。 JSX的痛点（项目开发中遇到的）写jsx模板的时候，我们遇到循环输出子组件或者标签，需要通过Array.forEach或者for循环输出；判断选择子组件的时候，需要通过if或者三元判断输出；一个模板里面我们会很多逻辑，这些逻辑看起来跟jsx不是很和谐！有没有办法做到标签化，跟jsx语法一致尼？ jsx-control-statements介绍安装1npm install --save-dev babel-plugin-jsx-control-statements 配置.babelrc1234&#123; ... \"plugins\": [\"jsx-control-statements\"]&#125; jsx-control-statements语法If（但是目前不支持Else，这也是可惜的） // 简单例子 IfBlock // 使用多个子元素或者表达式 &lt;If condition={ true }&gt; one { &quot;two&quot; } &lt;span&gt;three&lt;/span&gt; &lt;span&gt;four&lt;/span&gt; &lt;/If&gt; // 转化前 &lt;If condition={ test }&gt; &lt;span&gt;Truth&lt;/span&gt; &lt;/If&gt; // 转化后 { test ? &lt;span&gt;Truth&lt;/span&gt; : null } Choose、When、Otherwise（ 相当于switch case defualt） // 转化前 &lt;Choose&gt; &lt;When condition={ test1 }&gt; &lt;span&gt;IfBlock1&lt;/span&gt; &lt;/When&gt; &lt;When condition={ test2 }&gt; &lt;span&gt;IfBlock2&lt;/span&gt; &lt;/When&gt; &lt;Otherwise&gt; &lt;span&gt;ElseBlock&lt;/span&gt; &lt;/Otherwise&gt; &lt;/Choose&gt; // 转化后 { test1 ? &lt;span&gt;IfBlock1&lt;/span&gt; : test2 ? &lt;span&gt;IfBlock2&lt;/span&gt; : &lt;span&gt;ElseBlock&lt;/span&gt; } For // 循环输出的时候必须提供key { item.title } // 如果数组改变，则使用索引作为键属性是不稳定的 &lt;For each=&quot;item&quot; index=&quot;idx&quot; of={ [1,2,3] }&gt; &lt;span key={ idx }&gt;{ item }&lt;/span&gt; &lt;span key={ idx + &apos;_2&apos; }&gt;Static Text&lt;/span&gt; &lt;/For&gt; 参考https://github.com/AlexGilleran/jsx-control-statementsJSX 介绍JSX 深入","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React优化-记忆化技术-提升你的React性能","slug":"React优化-记忆化技术-提升你的React性能","date":"2018-06-15T06:14:31.000Z","updated":"2018-06-15T09:11:50.312Z","comments":true,"path":"2018/06/15/React优化-记忆化技术-提升你的React性能/","link":"","permalink":"http://yoursite.com/2018/06/15/React优化-记忆化技术-提升你的React性能/","excerpt":"","text":"为什么要使用记忆性技术？使用React开发的时候，我们请求服务器拿回来一个复杂的数据，我们在render里去处理这个数据，但是state和props频繁修改会触发render，每次触发render，数据都要去处理一次，每次处理都是对性能的损耗 举个例子：把大于18岁的人列出来123456789101112131415class Example extends Component &#123; ... render() &#123; const &#123; dataList &#125; = this.props; const newDataList = dataList.filter((item) =&gt; item.age &gt; 18); return ( &lt;div&gt; &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; &lt;/div&gt; ) &#125; ...&#125; 从例子中我们看到render中我们处理数据，但是每次state和props的修改都会触发render，都会去处理数据dataList，生成新的数据newDataList，每次处理都是对性能的损耗！ 什么叫记忆性技术？每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！ memoize-one官方案例123456789101112131415161718import memoizeOne from 'memoize-one';const add = (a, b) =&gt; a + b;const memoizedAdd = memoizeOne(add);memoizedAdd(1, 2); // 3memoizedAdd(1, 2); // 3// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(2, 3); // 5// Add 函数再次被调用，返回一个新的结果memoizedAdd(2, 3); // 5// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(1, 2); // 3// Add 函数再次被调用，返回一个新的结果 我们可以发现连续两次相同传参，第二次会直接返回上次的结果，每次传参不一样，就直接调用函数返回新的结果，会丢失之前的记录，并不是完全记忆，这也是个不足点！ 在React中使用memoize-one根据上的例子，我们对那个例子进行修改，使用memoize-one提升React的性能1234567891011121314151617181920import memoize from \"memoize-one\";class Example extends Component &#123; ... filter = memoize((dataList, age) =&gt; dataList.filter((item) =&gt; item.age &gt; age)) render() &#123; const &#123; dataList &#125; = this.props; const newDataList = this.filter(dataList, 18) return ( &lt;div&gt; ... &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; ... &lt;/div&gt; ) &#125; ...&#125; memoize-one源码解析memoize-one是采用闭包来缓存数据的1234567891011121314151617181920212223242526272829303132type EqualityFn = (a: mixed, b: mixed) =&gt; boolean;const simpleIsEqual: EqualityFn = (a: mixed, b: mixed): boolean =&gt; a === b;export default function &lt;ResultFn: (...Array&lt;any&gt;) =&gt; mixed&gt;(resultFn: ResultFn, isEqual?: EqualityFn = simpleIsEqual): ResultFn &#123; let lastThis: mixed; // 用来缓存上一次result函数对象 let lastArgs: Array&lt;mixed&gt; = []; // 用来缓存上一次的传参 let lastResult: mixed; // 用来缓存上一次的结果 let calledOnce: boolean = false; // 是否之前调用过 // 判断两次调用的时候的参数是否相等 // 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等 const isNewArgEqualToLast = (newArg: mixed, index: number): boolean =&gt; isEqual(newArg, lastArgs[index]); const result = function (...newArgs: Array&lt;mixed&gt;) &#123; if (calledOnce &amp;&amp; lastThis === this &amp;&amp; newArgs.length === lastArgs.length &amp;&amp; newArgs.every(isNewArgEqualToLast)) &#123; // 返回之前的结果 return lastResult; &#125; calledOnce = true; // 标记已经调用过 lastThis = this; // 重新缓存result对象 lastArgs = newArgs; // 重新缓存参数 lastResult = resultFn.apply(this, newArgs); // 重新缓存结果 return lastResult; // 返回新的结果 &#125;; // 返回闭包函数 return (result: any);&#125; 关于isEqual函数（memoize-one推荐使用loadsh.isEqual）一般两个对象比较是否相等，我们不能用===或者==来处理，memoize-one允许用户自定义传入判断是否相等的函数，比如我们可以使用lodash的isEqual来判断两次参数是否相等1234567891011121314151617import memoizeOne from 'memoize-one';import deepEqual from 'lodash.isEqual';const identity = x =&gt; x;const defaultMemoization = memoizeOne(identity);const customMemoization = memoizeOne(identity, deepEqual);const result1 = defaultMemoization(&#123;foo: 'bar'&#125;);const result2 = defaultMemoization(&#123;foo: 'bar'&#125;);result1 === result2 // false - 索引不同const result3 = customMemoization(&#123;foo: 'bar'&#125;);const result4 = customMemoization(&#123;foo: 'bar'&#125;);result3 === result4 // true - 参数通过lodash.isEqual判断是相等的 参考https://github.com/alexreardon/memoize-one","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Webpack小技巧-公共组件引用路径简化","slug":"webpack小技巧-公共组件引用路径简化","date":"2018-06-15T06:02:10.000Z","updated":"2018-09-06T07:32:41.426Z","comments":true,"path":"2018/06/15/webpack小技巧-公共组件引用路径简化/","link":"","permalink":"http://yoursite.com/2018/06/15/webpack小技巧-公共组件引用路径简化/","excerpt":"","text":"日常开发中，我们会常常把一些功能提取出来，包装成一个公共模块或者组件，供不同地方使用，但是随着项目不断变大，项目目录不断变深，我们引用公共组件的路径越来越长！ 例如：引用一个公共模块1import Menu from '../../../../../components/Menu'; // 这里路径太深，很容易写错 我们该怎么优化尼？ 解决方案1：使用webpack的resolve.alias属性先配置webpack123456789module.exports = &#123; ... resolve: &#123; alias: &#123; \"@commModule\": path.resolve(__dirname, \"src/components/\") &#125; &#125; ...&#125;; 引用Menu模块1import Menu from '@commModule/Menu'; 解决方案2：babel-plugin-module-resolver配置.babelrc123456789&#123; \"plugins\": [ [\"module-resolver\", &#123; \"alias\": &#123; \"@commMdule\": \"./src/components\" &#125; &#125;] ]&#125; 引用Menu模块1import Menu from '@commModule/Menu'; 总结或许这只是一个小优化，但是在实际场景中，能够大大的降低我们的维护成本，提高我们的生产效率！ 遗憾引用路径是简化了，但是VsCode不能快捷找到文件了","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]}]}