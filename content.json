{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-09T07:17:00.000Z","updated":"2018-05-09T07:17:00.623Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Tool-生成雪碧图（sprite）","slug":"Tool-生成雪碧图（sprite）","date":"2018-09-29T06:02:44.000Z","updated":"2018-09-29T06:42:44.981Z","comments":true,"path":"2018/09/29/Tool-生成雪碧图（sprite）/","link":"","permalink":"http://yoursite.com/2018/09/29/Tool-生成雪碧图（sprite）/","excerpt":"","text":"前言网站开发时，我们会使用会多小图标，很多小图标的调用一直都是个问题。 小图标使用方法图标字体（例如:阿里出品的iconfont）雪碧图（CSS Sprite）等等… 雪碧图（CSS雪碧）CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标和背景图像合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。 雪碧图优点 1. 减少加载网页图片时对服务器的请求次数 可以合并多数背景图片和小图标，方便在任何位置使用，这样不同位置的请求只需要调用一个图片，从而减少对服务器的请求次数，降低服务器压力，同时提高了页面的加载速度，节约服务器的流量 2. 提高页面的加载速度 sprite 技术的其中一个好处是图片的加载时间(在有许多 sprite 时，单张图片的加载时间)；单独的一张 JPEG 或者 PNG sprite 在大小上非常可能比把一张图分成多张得来的图片总尺寸小。 生成雪碧图PhotoShop（傻瓜方式）通过PhotoShop把图片合成一张大图，让后手动写css，定位到图标 Gulp生成雪碧图（项目链接）1234567891011121314var gulp = require('gulp');var spritesmith = require('gulp.spritesmith');gulp.task('sprite', function() &#123; // var DEST_NAME = args[1]; var spriteData = gulp.src('src/sprite-images/*.png').pipe(spritesmith(&#123; imgName: 'sprite.png', cssName: 'sprite.css', imgPath: '../images/sprite.png', // cssTemplate: 'sprite.template.handlebars' &#125;)); spriteData.css.pipe(gulp.dest('public/styles')); spriteData.img.pipe(gulp.dest('public/images'));&#125;); 合并前 合并后 Webpack生成雪碧图（项目链接）12345678910111213141516171819var SpritesmithPlugin = require('webpack-spritesmith');module.exports = &#123; plugins: [ new SpritesmithPlugin(&#123; src: &#123; cwd: 'src/sprite-images', glob: '*.png' &#125;, target: &#123; image: 'public/images/sprite.png', css: 'public/styles/sprite.css' &#125;, apiOptions: &#123; cssImageRef: \"../images/sprite.png\" &#125; &#125;) ]&#125;","categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"}]},{"title":"Javascript-apply、call、bind","slug":"Javascript-apply、call、bind","date":"2018-09-28T02:17:44.000Z","updated":"2018-09-28T03:53:27.752Z","comments":true,"path":"2018/09/28/Javascript-apply、call、bind/","link":"","permalink":"http://yoursite.com/2018/09/28/Javascript-apply、call、bind/","excerpt":"","text":"apply、call、bind的作用在javascript中，三者作用是改变某个函数的执行上下文（Execution Context），具体作用是改变函数体内部this的指向。 举个栗子： 12345678910111213141516function example() &#123;&#125;example.prototype = &#123; name: 'will', say: function() &#123; console.log('hi,' + this.name + '!') &#125;&#125;var e = new example()e.say() // hi,will!var obj = &#123; name: 'lucky'&#125;e.say.apply(obj) // hi,lucky! 此时this.name是luckye.say.call(obj) // hi,lucky! 此时this.name是luckye.say.bind(obj)() // hi,lucky! 此时this.name是lucky apply、call、bind的区别apply、call只是接受参数的方式不太一样，而且会立即执行，bind会产生一个新函数，需要再次调用才会执行 举个栗子： 12345function func(arg1, arg2) &#123; console.log(arg1 + arg2)&#125;func.apply(this, [1, 2]) // apply接受的参数，第一个是对象，第二个是数组func.call(this, 1, 2) // call接受的参数，第一个是对象，后面一个接一个 简单举几个apply、call、bind的应用场景伪数组转标准数组1234567var obj = &#123; 0: 1, 1: 2, length: 2&#125;var arr1 = Array.prototype.slice.call(obj) // [1, 2]var arr2 = Array.prototype.slice.apply(obj) // [1, 2] 取数组中的最大值或者最小值123456789var arr = [1, 2, 3, 4]//取最大值console.log(Math.max.apply(Math, arr)) // 4console.log(Math.max.call(Math, ...arr)) // 4//取最小值console.log(Math.min.apply(Math, arr)) // 1console.log(Math.min.call(Math, ...arr)) // 1 检验是否是数组12345function isArray(obj) &#123; return Object.prototype.toString.call(obj) === '[object Array]'&#125;isArray([1]) // trueisArray(&#123;&#125;) // false React中使用bind使函数可以获取到props12345678910class MyCircle extends Component &#123; constructor(props) &#123; super(props) this.func = this.func.bind(this) &#125; func() &#123; ... &#125; ...&#125; 等等…总结三者作用都是改变函数this的指向三者第一个传参都是要this要指向的对象apply、call是立即执行函数，bind需要再次调用","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript-伪数组","slug":"Javascript-伪数组","date":"2018-09-27T06:34:27.000Z","updated":"2018-09-27T08:04:27.906Z","comments":true,"path":"2018/09/27/Javascript-伪数组/","link":"","permalink":"http://yoursite.com/2018/09/27/Javascript-伪数组/","excerpt":"","text":"什么是伪数组伪数组是一个含有length属性的json对象 例如：12345&#123; 0: 1, 1: 2, length: 2&#125; 常见的伪数组arguments、NodeList、HTMLCollection、Jquery对象… 伪数据如何转成标准数组 使用Array.slice 1234567function toArray() &#123; console.log(arguments instanceof Array) // false arguments = Array.prototype.slice.call(arguments) console.log(arguments instanceof Array) // true return arguments&#125;toArray(1,2,3) // [1, 2, 3] Array.slice源码解析（587行）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function ArraySlice(start, end) &#123; CHECK_OBJECT_COERCIBLE(this, \"Array.prototype.slice\"); var array = TO_OBJECT(this); var len = TO_LENGTH(array.length); // 取数据length var start_i = TO_INTEGER(start); // 开始值转Number var end_i = len; // 结束值直接取array的length if (!IS_UNDEFINED(end)) end_i = TO_INTEGER(end); // 参数有end则使用end if (start_i &lt; 0) &#123; // 开始值为负数，重新计算值，从尾部往前推算 start_i += len; if (start_i &lt; 0) start_i = 0; // 负数的绝对值超过长度，开始值赋值为0 &#125; else &#123; if (start_i &gt; len) start_i = len; // 开始值超过长度, 开始值赋值为len &#125; if (end_i &lt; 0) &#123; // 结束值为负数，重新计算值，从尾部往前推算 end_i += len; if (end_i &lt; 0) end_i = 0; // 负数的绝对值超过长度，结束值赋值为0 &#125; else &#123; if (end_i &gt; len) end_i = len; // 开始值超过长度, 结束值赋值为len &#125; var result = ArraySpeciesCreate(array, MaxSimple(end_i - start_i, 0)); // 创建一个数组 if (end_i &lt; start_i) return result; // 结束值小于开始值，那么直接返回空数组 if (UseSparseVariant(array, len, IS_ARRAY(array), end_i - start_i)) &#123; // array是数组 %NormalizeElements(array); if (IS_ARRAY(result)) %NormalizeElements(result); SparseSlice(array, start_i, end_i - start_i, len, result); &#125; else &#123; // array不是数组 SimpleSlice(array, start_i, end_i - start_i, len, result); &#125; result.length = end_i - start_i; // 数组长度赋值 return result;&#125;/** array 具体操作的数组* start_i 开始位置* del_count 需要处理的长度* len 数组长度* deleted_elements 利用浅拷贝，返回结果，对于slice来说，是选择的那部分数组，对于splice来说，是删除的那些数组*/function SparseSlice(array, start_i, del_count, len, deleted_elements) &#123; // Move deleted elements to a new array (the return value from splice). var indices = %GetArrayKeys(array, start_i + del_count); if (IS_NUMBER(indices)) &#123; var limit = indices; for (var i = start_i; i &lt; limit; ++i) &#123; var current = array[i]; if (!IS_UNDEFINED(current) || i in array) &#123; %CreateDataProperty(deleted_elements, i - start_i, current); &#125; &#125; &#125; else &#123; var length = indices.length; for (var k = 0; k &lt; length; ++k) &#123; var key = indices[k]; if (key &gt;= start_i) &#123; var current = array[key]; if (!IS_UNDEFINED(current) || key in array) &#123; %CreateDataProperty(deleted_elements, key - start_i, current); &#125; &#125; &#125; &#125;&#125;/** array 具体操作的数组* start_i 开始位置* del_count 需要处理的长度* len 数组长度* deleted_elements 利用浅拷贝，返回结果，对于slice来说，是选择的那部分数组，对于splice来说，是删除的那些数组*/function SimpleSlice(array, start_i, del_count, len, deleted_elements) &#123; for (var i = 0; i &lt; del_count; i++) &#123; var index = start_i + i; if (index in array) &#123; var current = array[index]; %CreateDataProperty(deleted_elements, i, current); &#125; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript-JSON.parse与JSON.stringify的实现","slug":"JSON-parse与JSON-stringify的实现","date":"2018-09-11T08:09:37.000Z","updated":"2018-09-29T09:51:33.001Z","comments":true,"path":"2018/09/11/JSON-parse与JSON-stringify的实现/","link":"","permalink":"http://yoursite.com/2018/09/11/JSON-parse与JSON-stringify的实现/","excerpt":"","text":"JSON.stringify简单实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function stringify(obj) &#123; var result = '', curVal; if (obj === null) &#123; return String(obj); &#125; switch (typeof obj) &#123; case 'number': case 'boolean': return String(obj); case 'string': return '\"' + obj + '\"'; case 'undefined': case 'function': return undefined; &#125; switch (Object.prototype.toString.call(obj)) &#123; case '[object Array]': result += '['; for (var i = 0, len = obj.length; i &lt; len; i++) &#123; curVal = JSON.stringify(obj[i]); result += (curVal === undefined ? null : curVal) + ','; &#125; if (result !== '[') &#123; result = result.slice(0, -1); &#125; result += ']'; return result; case '[object Date]': return '\"' + (obj.toJSON ? obj.toJSON() : obj.toString()) + '\"'; case '[object RegExp]': return '&#123;&#125;'; case '[object Object]': result += '&#123;'; for (i in obj) &#123; if (obj.hasOwnProperty(i)) &#123; curVal = JSON.stringify(obj[i]); if (curVal !== undefined) &#123; result += '\"' + i + '\":' + curVal + ','; &#125; &#125; &#125; if (result !== '&#123;') &#123; result = result.slice(0, -1); &#125; result += '&#125;'; return result; case '[object String]': return '\"' + obj.toString() + '\"'; case '[object Number]': case '[object Boolean]': return obj.toString(); &#125;&#125; JSON.parse简单实现1:通过eval123function parse(str) &#123; return eval('(' + str + ')')&#125; 简单实现2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227function parse(text) &#123; var at = 0; var ch = ' '; var escapee = &#123; '\"': '\"', '\\\\': '\\\\', '/': '/', b: '\\b', f: '\\f', n: '\\n', r: '\\r', t: '\\t' &#125;; var error = function(m) &#123; throw &#123; name: 'SyntaxError', message: m, at: at, text: text &#125;; &#125;; var next = function(c) &#123; if (c &amp;&amp; c !== ch) &#123; error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\"); &#125; ch = text.charAt(at); at = at + 1; return ch; &#125;; var white = function() &#123; while (ch &amp;&amp; ch &lt;= ' ') &#123; next(); &#125; &#125;; var number = function() &#123; var number; var string = ''; if (ch === '-') &#123; string = '-'; next('-'); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; string += ch; next(); &#125; if (ch === '.') &#123; string += '.'; while (next() &amp;&amp; ch &gt;= '0' &amp;&amp; ch &lt;= 9) &#123; string += ch; &#125; &#125; if (ch === 'e' || ch === 'E') &#123; string += ch; next(); if (ch === '-' || ch === '+') &#123; string += ch; next(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; string += ch; next(); &#125; &#125; number = string - 0; if (!isFinite(number)) &#123; error('Bad number'); &#125; else &#123; return number; &#125; &#125;; var string = function() &#123; var hex; var i; var string = ''; var uffff; if (ch === '\"') &#123; while (next()) &#123; if (ch === '\"') &#123; next(); return string; // 空字符串 &#125; if (ch === '\\\\') &#123; next(); if (ch === 'u') &#123; uffff = 0; for (var i = 0; i &lt; 4; i += 1) &#123; hex = parseInt(next(), 16); if (!isFinite(hex)) &#123; break; &#125; uffff = uffff * 16 + hex; &#125; string += String.fromCharCode(uffff); &#125; else if (typeof escapee[ch] === 'string') &#123; string += escapee[ch]; &#125; else &#123; break; &#125; &#125; else &#123; string += ch; &#125; &#125; &#125; error('Bad string'); &#125;; var word = function() &#123; switch (ch) &#123; case 't': next('t'); next('r'); next('u'); next('e'); return true; case 'f': next('f'); next('a'); next('l'); next('s'); next('e'); return false; case 'n': next('n'); next('u'); next('l'); next('l'); return null; &#125; error(\"Unexpected '\" + ch + \"'\"); &#125;; var value; var array = function() &#123; var array = []; if (ch === '[') &#123; next('['); white(); if (ch === ']') &#123; next(']'); return array; // 空数组 &#125; while (ch) &#123; array.push(value()); white(); if (ch === ']') &#123; next(']'); return array; &#125; next(','); white(); &#125; &#125; error('Bad array'); &#125;; var object = function() &#123; var key; var object = &#123;&#125;; if (ch === '&#123;') &#123; next('&#123;'); white(); if (ch === '&#125;') &#123; next('&#125;'); return object; // 空对象 &#125; while (ch) &#123; key = string(); white(); next(':'); if (Object.hasOwnProperty.call(object, key)) &#123; error('Duplicate key \"' + key + '\"'); &#125; object[key] = value(); white(); if (ch === '&#125;') &#123; next('&#125;'); return object; &#125; next(','); white(); &#125; &#125; error('Bad object'); &#125;; value = function() &#123; white(); switch (ch) &#123; case '&#123;': return object(); case '[': return array(); case '\"': return string(); case '-': return number(); default: return ch &gt;= '0' &amp;&amp; ch &lt;= '9' ? number() : word(); &#125; &#125;; return value(text);&#125; 参考https://segmentfault.com/a/1190000016196021https://blog.csdn.net/wlx1991/article/details/50959618","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript-函数防抖与函数节流","slug":"函数防抖与函数节流","date":"2018-09-06T07:44:06.000Z","updated":"2018-09-29T09:51:56.828Z","comments":true,"path":"2018/09/06/函数防抖与函数节流/","link":"","permalink":"http://yoursite.com/2018/09/06/函数防抖与函数节流/","excerpt":"","text":"函数节流（throttle）名词解释函数节流（throttle）：连续执行函数，每隔一定时间执行函数 使用场景鼠标移动，mousemove 事件DOM 元素动态定位，window对象的resize和scroll 事件等等… 函数节流（throttle）简单实现1234567891011121314151617181920function throttle(fn, delay) &#123; var last; // 上次执行的时间 var timer; // 定时器 delay || (delay = 250); // 默认间隔为250ms return function() &#123; var context = this; var args = arguments; var now = +new Date(); // 现在的时间 if (last &amp;&amp; now &lt; last + delay) &#123; // 当前距离上次执行的时间小于设置的时间间隔 clearTimeout(timer); // 清除定时器 timer = setTimeout(function() &#123; // delay时间后，执行函数 last = now; fn.apply(context, args); &#125;, delay); &#125; else &#123; // 当前距离上次执行的时间大于等于设置的时间，直接执行函数 last = now; fn.apply(context, args); &#125; &#125;;&#125; 函数防抖（debounce）名词解释函数防抖（debounce）：空闲时间必须大于或等于一定值的时候，才会执行调用方法 使用场景文本输入keydown 事件等等… 函数防抖（debounce）简单实现123456789101112function debounce(fn, delay) &#123; var timer; // 定时器 delay || (delay = 250); // 默认空闲时间250ms return function() &#123; var context = this; var args = arguments; clearTimeout(timer); // 清除定时器 timer = setTimeout(function() &#123; // delay时间后，执行函数 fn.apply(context, args); &#125;, delay); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Javascript-深浅拷贝","slug":"深浅拷贝","date":"2018-08-16T06:01:04.000Z","updated":"2018-09-29T09:52:00.257Z","comments":true,"path":"2018/08/16/深浅拷贝/","link":"","permalink":"http://yoursite.com/2018/08/16/深浅拷贝/","excerpt":"","text":"深浅拷贝简介javascript中对于Object和Array这两个类型，把一个变量赋值给另一个变量；浅拷贝只是对拷贝对象的引用，深拷贝是彻底拷贝，生成一个新的属性相同的对象 浅拷贝（shallow copy） 浅拷贝只是对拷贝对的引用，两者相互影响 浅拷贝的实现1.简单赋值实现例子：obj2拷贝了obj1，obj2改变，obj1也会改变，改变之后2者还是相同的123456var obj1 = &#123;a: 1&#125;var obj2 = obj1obj2.b = 2console.log(obj1) // &#123;a: 1, b: 2&#125;console.log(obj2) //&#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // true Object.assign()实现例子：当第一个传参是你需要拷贝的对象（PS：Object.assign()也可以实现深拷贝）123456var obj1 = &#123;a: 1&#125;var obj2 = Object.assign(obj1)obj2.b = 2console.log(obj1) // &#123;a: 1, b: 2&#125;console.log(obj2) // &#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // true 深拷贝（deep copy） 彻底拷贝，生成一个新的属性相同的对象 深拷贝的实现Object.assign()实现例子：拷贝对象不是第一个传参123456var obj1 = &#123;a: 1&#125;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125;console.log(obj1 == obj2) // false Array.slice()可以实现数组的深拷贝（数组中不能有Object和Array，Object和Array只是浅拷贝）1234567var arr1 = [1, [2]]var arr2 = arr1.slice()arr2[1].push(3)arr2.push(4)console.log(arr1) // [1, [2, 3]]console.log(arr2) // [1, [2, 3], 4]console.log(arr1 == arr2) // false JSON.stringify()和JSON.parse()实现123456var obj1 = &#123;a: 1&#125;var obj2 = JSON.parse(JSON.stringify(obj1))console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; 递归实现12345678910111213141516var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125;var obj1 = &#123;a: 1&#125;var obj2 = deepCopy(obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; Object.create()实现12345678910111213141516var deepCopy = function(obj) &#123; if (typeof obj !== 'object') return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] === 'object' ? Object.create(obj[key]) : obj[key]; &#125; &#125; return newObj;&#125;var obj1 = &#123;a: 1&#125;var obj2 = deepCopy(obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; jQuery.extend()实现123456var obj1 = &#123;a: 1&#125;var obj2 = $.extend(true, &#123;&#125;, obj1)console.log(obj1 == obj2) // falseobj2.b = 2console.log(obj1) // &#123;a: 1&#125;console.log(obj2) // &#123;a: 1, b: 2&#125; jQuery.extend()源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263jQuery.extend = jQuery.fn.extend = function() &#123; var src, copyIsArray, copy, name, options, clone, target = arguments[0] || &#123;&#125;, // 默认取第一个参数赋值给target i = 1, length = arguments.length, // 获取参数的个数 deep = false; // 默认浅拷贝 // Handle a deep copy situation if ( typeof target === \"boolean\" ) &#123; // 如果第一个参数类型为boolean，那么把该参数赋值给局部变量deep deep = target; target = arguments[1] || &#123;&#125;; // 把第二个参数赋值给target // skip the boolean and the target i = 2; &#125; // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" &amp;&amp; !jQuery.isFunction(target) ) &#123; // target不是object类型或者不是function，就赋值&#123;&#125; target = &#123;&#125;; &#125; // extend jQuery itself if only one argument is passed if ( length === i ) &#123; // 如果只有一个参数，这时候i就是1，length也就是1，那么把target设置为调用者，也就是jQuery对象本身!同时把i递减为0 target = this; // this就是jQuery --i; &#125; for ( ; i &lt; length; i++ ) &#123; // 循环参数 // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) &#123; // Extend the base object for ( name in options ) &#123; src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) &#123; // 防止无休止循环 continue; &#125; // Recurse if we're merging plain objects or arrays // deep是否深拷贝，copy是参数属性值 if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) &#123; if ( copyIsArray ) &#123; // 被拷贝的属性值是数组 copyIsArray = false; clone = src &amp;&amp; jQuery.isArray(src) ? src : []; &#125; else &#123; // 不是数组 clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : &#123;&#125;; &#125; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // 递归~ // Don't bring in undefined values &#125; else if ( copy !== undefined ) &#123; // 浅拷贝，且属性值不为undefined target[ name ] = copy; &#125; &#125; &#125; &#125; // Return the modified object return target;&#125;; 更多方法…敬请期待","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React-JSX模板优化-标签化","slug":"React优化-JSX模板优化-标签化","date":"2018-06-20T03:31:43.000Z","updated":"2018-09-29T09:52:39.590Z","comments":true,"path":"2018/06/20/React优化-JSX模板优化-标签化/","link":"","permalink":"http://yoursite.com/2018/06/20/React优化-JSX模板优化-标签化/","excerpt":"","text":"什么是JSXJSX是JavaScrip的一种扩展语法，JSX的标签语法既不是字符串也不是HTML；从本质上讲，JSX只是为React.createElement(component, props, …children)函数提供的语法糖。 JSX的痛点（项目开发中遇到的）写jsx模板的时候，我们遇到循环输出子组件或者标签，需要通过Array.forEach或者for循环输出；判断选择子组件的时候，需要通过if或者三元判断输出；一个模板里面我们会很多逻辑，这些逻辑看起来跟jsx不是很和谐！有没有办法做到标签化，跟jsx语法一致尼？ jsx-control-statements介绍安装1npm install --save-dev babel-plugin-jsx-control-statements 配置.babelrc1234&#123; ... \"plugins\": [\"jsx-control-statements\"]&#125; jsx-control-statements语法If（但是目前不支持Else，这也是可惜的） // 简单例子 IfBlock // 使用多个子元素或者表达式 &lt;If condition={ true }&gt; one { &quot;two&quot; } &lt;span&gt;three&lt;/span&gt; &lt;span&gt;four&lt;/span&gt; &lt;/If&gt; // 转化前 &lt;If condition={ test }&gt; &lt;span&gt;Truth&lt;/span&gt; &lt;/If&gt; // 转化后 { test ? &lt;span&gt;Truth&lt;/span&gt; : null } Choose、When、Otherwise（ 相当于switch case defualt） // 转化前 &lt;Choose&gt; &lt;When condition={ test1 }&gt; &lt;span&gt;IfBlock1&lt;/span&gt; &lt;/When&gt; &lt;When condition={ test2 }&gt; &lt;span&gt;IfBlock2&lt;/span&gt; &lt;/When&gt; &lt;Otherwise&gt; &lt;span&gt;ElseBlock&lt;/span&gt; &lt;/Otherwise&gt; &lt;/Choose&gt; // 转化后 { test1 ? &lt;span&gt;IfBlock1&lt;/span&gt; : test2 ? &lt;span&gt;IfBlock2&lt;/span&gt; : &lt;span&gt;ElseBlock&lt;/span&gt; } For // 循环输出的时候必须提供key { item.title } // 如果数组改变，则使用索引作为键属性是不稳定的 &lt;For each=&quot;item&quot; index=&quot;idx&quot; of={ [1,2,3] }&gt; &lt;span key={ idx }&gt;{ item }&lt;/span&gt; &lt;span key={ idx + &apos;_2&apos; }&gt;Static Text&lt;/span&gt; &lt;/For&gt; 参考https://github.com/AlexGilleran/jsx-control-statementsJSX 介绍JSX 深入","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-记忆化技术-提升你的React性能","slug":"React优化-记忆化技术-提升你的React性能","date":"2018-06-15T06:14:31.000Z","updated":"2018-09-29T09:52:35.047Z","comments":true,"path":"2018/06/15/React优化-记忆化技术-提升你的React性能/","link":"","permalink":"http://yoursite.com/2018/06/15/React优化-记忆化技术-提升你的React性能/","excerpt":"","text":"为什么要使用记忆性技术？使用React开发的时候，我们请求服务器拿回来一个复杂的数据，我们在render里去处理这个数据，但是state和props频繁修改会触发render，每次触发render，数据都要去处理一次，每次处理都是对性能的损耗 举个例子：把大于18岁的人列出来123456789101112131415class Example extends Component &#123; ... render() &#123; const &#123; dataList &#125; = this.props; const newDataList = dataList.filter((item) =&gt; item.age &gt; 18); return ( &lt;div&gt; &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; &lt;/div&gt; ) &#125; ...&#125; 从例子中我们看到render中我们处理数据，但是每次state和props的修改都会触发render，都会去处理数据dataList，生成新的数据newDataList，每次处理都是对性能的损耗！ 什么叫记忆性技术？每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！ memoize-one官方案例123456789101112131415161718import memoizeOne from 'memoize-one';const add = (a, b) =&gt; a + b;const memoizedAdd = memoizeOne(add);memoizedAdd(1, 2); // 3memoizedAdd(1, 2); // 3// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(2, 3); // 5// Add 函数再次被调用，返回一个新的结果memoizedAdd(2, 3); // 5// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(1, 2); // 3// Add 函数再次被调用，返回一个新的结果 我们可以发现连续两次相同传参，第二次会直接返回上次的结果，每次传参不一样，就直接调用函数返回新的结果，会丢失之前的记录，并不是完全记忆，这也是个不足点！ 在React中使用memoize-one根据上的例子，我们对那个例子进行修改，使用memoize-one提升React的性能1234567891011121314151617181920import memoize from \"memoize-one\";class Example extends Component &#123; ... filter = memoize((dataList, age) =&gt; dataList.filter((item) =&gt; item.age &gt; age)) render() &#123; const &#123; dataList &#125; = this.props; const newDataList = this.filter(dataList, 18) return ( &lt;div&gt; ... &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; ... &lt;/div&gt; ) &#125; ...&#125; memoize-one源码解析memoize-one是采用闭包来缓存数据的1234567891011121314151617181920212223242526272829303132type EqualityFn = (a: mixed, b: mixed) =&gt; boolean;const simpleIsEqual: EqualityFn = (a: mixed, b: mixed): boolean =&gt; a === b;export default function &lt;ResultFn: (...Array&lt;any&gt;) =&gt; mixed&gt;(resultFn: ResultFn, isEqual?: EqualityFn = simpleIsEqual): ResultFn &#123; let lastThis: mixed; // 用来缓存上一次result函数对象 let lastArgs: Array&lt;mixed&gt; = []; // 用来缓存上一次的传参 let lastResult: mixed; // 用来缓存上一次的结果 let calledOnce: boolean = false; // 是否之前调用过 // 判断两次调用的时候的参数是否相等 // 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等 const isNewArgEqualToLast = (newArg: mixed, index: number): boolean =&gt; isEqual(newArg, lastArgs[index]); const result = function (...newArgs: Array&lt;mixed&gt;) &#123; if (calledOnce &amp;&amp; lastThis === this &amp;&amp; newArgs.length === lastArgs.length &amp;&amp; newArgs.every(isNewArgEqualToLast)) &#123; // 返回之前的结果 return lastResult; &#125; calledOnce = true; // 标记已经调用过 lastThis = this; // 重新缓存result对象 lastArgs = newArgs; // 重新缓存参数 lastResult = resultFn.apply(this, newArgs); // 重新缓存结果 return lastResult; // 返回新的结果 &#125;; // 返回闭包函数 return (result: any);&#125; 关于isEqual函数（memoize-one推荐使用loadsh.isEqual）一般两个对象比较是否相等，我们不能用===或者==来处理，memoize-one允许用户自定义传入判断是否相等的函数，比如我们可以使用lodash的isEqual来判断两次参数是否相等1234567891011121314151617import memoizeOne from 'memoize-one';import deepEqual from 'lodash.isEqual';const identity = x =&gt; x;const defaultMemoization = memoizeOne(identity);const customMemoization = memoizeOne(identity, deepEqual);const result1 = defaultMemoization(&#123;foo: 'bar'&#125;);const result2 = defaultMemoization(&#123;foo: 'bar'&#125;);result1 === result2 // false - 索引不同const result3 = customMemoization(&#123;foo: 'bar'&#125;);const result4 = customMemoization(&#123;foo: 'bar'&#125;);result3 === result4 // true - 参数通过lodash.isEqual判断是相等的 参考https://github.com/alexreardon/memoize-one","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Webpack-公共组件引用路径简化","slug":"webpack小技巧-公共组件引用路径简化","date":"2018-06-15T06:02:10.000Z","updated":"2018-09-29T09:52:27.393Z","comments":true,"path":"2018/06/15/webpack小技巧-公共组件引用路径简化/","link":"","permalink":"http://yoursite.com/2018/06/15/webpack小技巧-公共组件引用路径简化/","excerpt":"","text":"日常开发中，我们会常常把一些功能提取出来，包装成一个公共模块或者组件，供不同地方使用，但是随着项目不断变大，项目目录不断变深，我们引用公共组件的路径越来越长！ 例如：引用一个公共模块1import Menu from '../../../../../components/Menu'; // 这里路径太深，很容易写错 我们该怎么优化尼？ 解决方案1：使用webpack的resolve.alias属性先配置webpack123456789module.exports = &#123; ... resolve: &#123; alias: &#123; \"@commModule\": path.resolve(__dirname, \"src/components/\") &#125; &#125; ...&#125;; 引用Menu模块1import Menu from '@commModule/Menu'; 解决方案2：babel-plugin-module-resolver配置.babelrc123456789&#123; \"plugins\": [ [\"module-resolver\", &#123; \"alias\": &#123; \"@commMdule\": \"./src/components\" &#125; &#125;] ]&#125; 引用Menu模块1import Menu from '@commModule/Menu'; 总结或许这只是一个小优化，但是在实际场景中，能够大大的降低我们的维护成本，提高我们的生产效率！ 遗憾引用路径是简化了，但是VsCode不能快捷找到文件了","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]}]}