{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-05-09T07:17:00.000Z","updated":"2018-05-09T07:17:00.623Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"React优化-JSX模板优化-标签化","slug":"React优化-JSX模板优化-标签化","date":"2018-06-20T03:31:43.000Z","updated":"2018-06-20T03:32:23.846Z","comments":true,"path":"2018/06/20/React优化-JSX模板优化-标签化/","link":"","permalink":"http://yoursite.com/2018/06/20/React优化-JSX模板优化-标签化/","excerpt":"","text":"什么是JSXJSX是JavaScrip的一种扩展语法，JSX的标签语法既不是字符串也不是HTML；从本质上讲，JSX只是为React.createElement(component, props, …children)函数提供的语法糖。 JSX的痛点（项目开发中遇到的）写jsx模板的时候，我们遇到循环输出子组件或者标签，需要通过Array.forEach或者for循环输出；判断选择子组件的时候，需要通过if或者三元判断输出；一个模板里面我们会很多逻辑，这些逻辑看起来跟jsx不是很和谐！有没有办法做到标签化，跟jsx语法一致尼？ jsx-control-statements介绍安装1npm install --save-dev babel-plugin-jsx-control-statements 配置.babelrc1234&#123; ... \"plugins\": [\"jsx-control-statements\"]&#125; jsx-control-statements语法If（但是目前不支持Else，这也是可惜的） // 简单例子 IfBlock // 使用多个子元素或者表达式 &lt;If condition={ true }&gt; one { &quot;two&quot; } &lt;span&gt;three&lt;/span&gt; &lt;span&gt;four&lt;/span&gt; &lt;/If&gt; // 转化前 &lt;If condition={ test }&gt; &lt;span&gt;Truth&lt;/span&gt; &lt;/If&gt; // 转化后 { test ? &lt;span&gt;Truth&lt;/span&gt; : null } Choose、When、Otherwise（ 相当于switch case defualt） // 转化前 &lt;Choose&gt; &lt;When condition={ test1 }&gt; &lt;span&gt;IfBlock1&lt;/span&gt; &lt;/When&gt; &lt;When condition={ test2 }&gt; &lt;span&gt;IfBlock2&lt;/span&gt; &lt;/When&gt; &lt;Otherwise&gt; &lt;span&gt;ElseBlock&lt;/span&gt; &lt;/Otherwise&gt; &lt;/Choose&gt; // 转化后 { test1 ? &lt;span&gt;IfBlock1&lt;/span&gt; : test2 ? &lt;span&gt;IfBlock2&lt;/span&gt; : &lt;span&gt;ElseBlock&lt;/span&gt; } For // 循环输出的时候必须提供key { item.title } // 如果数组改变，则使用索引作为键属性是不稳定的 &lt;For each=&quot;item&quot; index=&quot;idx&quot; of={ [1,2,3] }&gt; &lt;span key={ idx }&gt;{ item }&lt;/span&gt; &lt;span key={ idx + &apos;_2&apos; }&gt;Static Text&lt;/span&gt; &lt;/For&gt; 参考https://github.com/AlexGilleran/jsx-control-statementsJSX 介绍JSX 深入","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React优化-记忆化技术-提升你的React性能","slug":"React优化-记忆化技术-提升你的React性能","date":"2018-06-15T06:14:31.000Z","updated":"2018-06-15T09:11:50.312Z","comments":true,"path":"2018/06/15/React优化-记忆化技术-提升你的React性能/","link":"","permalink":"http://yoursite.com/2018/06/15/React优化-记忆化技术-提升你的React性能/","excerpt":"","text":"为什么要使用记忆性技术？使用React开发的时候，我们请求服务器拿回来一个复杂的数据，我们在render里去处理这个数据，但是state和props频繁修改会触发render，每次触发render，数据都要去处理一次，每次处理都是对性能的损耗 举个例子：把大于18岁的人列出来123456789101112131415class Example extends Component &#123; ... render() &#123; const &#123; dataList &#125; = this.props; const newDataList = dataList.filter((item) =&gt; item.age &gt; 18); return ( &lt;div&gt; &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; &lt;/div&gt; ) &#125; ...&#125; 从例子中我们看到render中我们处理数据，但是每次state和props的修改都会触发render，都会去处理数据dataList，生成新的数据newDataList，每次处理都是对性能的损耗！ 什么叫记忆性技术？每次调用函数把你的传参和结果记录下来，遇到相同的传参，就直接返回记录缓存的结果，不用再去调用函数处理数据！ memoize-one官方案例123456789101112131415161718import memoizeOne from 'memoize-one';const add = (a, b) =&gt; a + b;const memoizedAdd = memoizeOne(add);memoizedAdd(1, 2); // 3memoizedAdd(1, 2); // 3// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(2, 3); // 5// Add 函数再次被调用，返回一个新的结果memoizedAdd(2, 3); // 5// Add 函数并没有执行: 前一次执行的结果被返回memoizedAdd(1, 2); // 3// Add 函数再次被调用，返回一个新的结果 我们可以发现连续两次相同传参，第二次会直接返回上次的结果，每次传参不一样，就直接调用函数返回新的结果，会丢失之前的记录，并不是完全记忆，这也是个不足点！ 在React中使用memoize-one根据上的例子，我们对那个例子进行修改，使用memoize-one提升React的性能1234567891011121314151617181920import memoize from \"memoize-one\";class Example extends Component &#123; ... filter = memoize((dataList, age) =&gt; dataList.filter((item) =&gt; item.age &gt; age)) render() &#123; const &#123; dataList &#125; = this.props; const newDataList = this.filter(dataList, 18) return ( &lt;div&gt; ... &#123;newDataList.map((item, i) =&gt; &lt;p key=&#123;i&#125;&gt;&#123;item.name&#125;:&#123;item.age&#125;岁&lt;/p&gt; )&#125; ... &lt;/div&gt; ) &#125; ...&#125; memoize-one源码解析memoize-one是采用闭包来缓存数据的1234567891011121314151617181920212223242526272829303132type EqualityFn = (a: mixed, b: mixed) =&gt; boolean;const simpleIsEqual: EqualityFn = (a: mixed, b: mixed): boolean =&gt; a === b;export default function &lt;ResultFn: (...Array&lt;any&gt;) =&gt; mixed&gt;(resultFn: ResultFn, isEqual?: EqualityFn = simpleIsEqual): ResultFn &#123; let lastThis: mixed; // 用来缓存上一次result函数对象 let lastArgs: Array&lt;mixed&gt; = []; // 用来缓存上一次的传参 let lastResult: mixed; // 用来缓存上一次的结果 let calledOnce: boolean = false; // 是否之前调用过 // 判断两次调用的时候的参数是否相等 // 这里的 `isEqual` 是一个抽象函数，用来判断两个值是否相等 const isNewArgEqualToLast = (newArg: mixed, index: number): boolean =&gt; isEqual(newArg, lastArgs[index]); const result = function (...newArgs: Array&lt;mixed&gt;) &#123; if (calledOnce &amp;&amp; lastThis === this &amp;&amp; newArgs.length === lastArgs.length &amp;&amp; newArgs.every(isNewArgEqualToLast)) &#123; // 返回之前的结果 return lastResult; &#125; calledOnce = true; // 标记已经调用过 lastThis = this; // 重新缓存result对象 lastArgs = newArgs; // 重新缓存参数 lastResult = resultFn.apply(this, newArgs); // 重新缓存结果 return lastResult; // 返回新的结果 &#125;; // 返回闭包函数 return (result: any);&#125; 关于isEqual函数（memoize-one推荐使用loadsh.isEqual）一般两个对象比较是否相等，我们不能用===或者==来处理，memoize-one允许用户自定义传入判断是否相等的函数，比如我们可以使用lodash的isEqual来判断两次参数是否相等1234567891011121314151617import memoizeOne from 'memoize-one';import deepEqual from 'lodash.isEqual';const identity = x =&gt; x;const defaultMemoization = memoizeOne(identity);const customMemoization = memoizeOne(identity, deepEqual);const result1 = defaultMemoization(&#123;foo: 'bar'&#125;);const result2 = defaultMemoization(&#123;foo: 'bar'&#125;);result1 === result2 // false - 索引不同const result3 = customMemoization(&#123;foo: 'bar'&#125;);const result4 = customMemoization(&#123;foo: 'bar'&#125;);result3 === result4 // true - 参数通过lodash.isEqual判断是相等的 参考https://github.com/alexreardon/memoize-one","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Webpack小技巧-公共组件引用路径简化","slug":"webpack小技巧-公共组件引用路径简化","date":"2018-06-15T06:02:10.000Z","updated":"2018-06-15T06:15:13.009Z","comments":true,"path":"2018/06/15/webpack小技巧-公共组件引用路径简化/","link":"","permalink":"http://yoursite.com/2018/06/15/webpack小技巧-公共组件引用路径简化/","excerpt":"","text":"日常开发中，我们会常常把一些功能提取出来，包装成一个公共模块或者组件，供不同地方使用，但是随着项目不断变大，项目目录不断变深，我们引用公共组件的路径越来越长！ 例如：引用一个公共模块1import Menu from '../../../../../components/Menu'; // 这里路径太深，很容易写错 我们该怎么优化尼？ 解决方案1：使用webpack的resolve.alias属性先配置webpack123456789module.exports = &#123; ... resolve: &#123; alias: &#123; \"@commModule\": path.resolve(__dirname, \"src/components/\") &#125; &#125; ...&#125;; 引用Menu模块1import Menu from '@commModule/Menu'; 解决方案2：babel-plugin-module-resolver配置.babelrc123456789&#123; \"plugins\": [ [\"module-resolver\", &#123; \"alias\": &#123; \"@commMdule\": \"./src/components\" &#125; &#125;] ]&#125; 引用Menu模块1import Menu from '@commModule/Menu'; 总结或许这只是一个小优化，但是在实际场景中，能够大大的降低我们的维护成本，提高我们的生产效率！","categories":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/categories/Webpack/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]}]}